<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>
        BASIC blog full text feed    </title>
        <link href="blog/atom.xml" rel="self" />
    
        <link href="/"/>
    
        
    <updated>2012-08-21T11:08:27Z</updated>

    <id>/blog/atom.xml/</id>

            <entry>
            <title type="html">使用Hyde建立静态网站</title>
            <author><name>newkedison</name></author>
            <link href="/blog/how-to-use-hyde.html"/>
            <updated>2012-08-19T10:51:16Z</updated>
            <published>2012-08-19T10:51:16Z</published>
            <id>/blog/how-to-use-hyde.html</id>
                        <category   scheme="/blog/tags"
                        term="hyde"
                        label="Hyde" />
                        <category   scheme="/blog/tags"
                        term="github"
                        label="Github" />
            
            <content type="html">
                                &lt;h6&gt;想到什么写什么, 暂时比较混乱,&amp;nbsp;等写完再整理&lt;/h6&gt;
&lt;h3&gt;hyde对jinja2的扩展&lt;/h3&gt;
&lt;p&gt;hyde号称支持多种模板系统, 但是目前仅支持jinja2, 这是一种与Django模板语法很类似的
模板系统,&amp;nbsp;这也是我选择hyde而不是JekyII的原因&lt;/p&gt;
&lt;p&gt;但是, hyde对jinja2进行了一些扩展, 导致我在看代码的时候, 碰到看不懂的地方去查
jinja2&amp;nbsp;的文档总是找不到说明&lt;/p&gt;
&lt;p&gt;下面列举目前我知道的hyde对jinja的扩展&lt;/p&gt;
&lt;h4&gt;filter(过滤器)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;{% content|markdow %}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;对content的内容按照markdown语法进行解析&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;{% content|typogrify %}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;对content的内容进行一些&amp;#8221;美化&amp;#8221;(我个人不认为很美), 
可参考&lt;a href=&#34;http://code.google.com/p/typogrify/&#34;&gt;这里&lt;/a&gt;的说明
(还有&lt;a href=&#34;http://static.mintchaos.com/projects/typogrify/&#34;&gt;demo&lt;/a&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;mark&amp;nbsp;tag(标记)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;{% mark name -%}...{%- endmark %}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个我还不知道干嘛用的,&amp;nbsp;可能需要和下面的refer配套使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;{% refer to XXX as YYY %}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个的具体用法也还没明白&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;替换网页模板&lt;/h3&gt;
&lt;p&gt;原来的模板比较难看, 我不得不换一个模板, 自己写一个模板就比较复杂了, 但是其实原来的
模板主要是&lt;span class=&#34;caps&#34;&gt;CSS&lt;/span&gt;比较难看,&amp;nbsp;于是主要工作变成了换&lt;span class=&#34;caps&#34;&gt;CSS&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;刚好前阵子稍微学习了一下bootstrap, 于是当然是换成整套的bootstrap, 在hyde的Github
主页上, 给了一个使用bootstrap的项目(见
&lt;a href=&#34;https://github.com/auzigog/hyde-bootstrap&#34;&gt;hyde-bootstrap&lt;/a&gt;)
于是我下载了压缩包, 然后把&lt;span class=&#34;caps&#34;&gt;CSS&lt;/span&gt;和js都弄过来, 接着修改layout文件夹里面几个模板文件的
内容, 慢慢调试(这其实就是个耐心活), 最后终于把原来的&lt;span class=&#34;caps&#34;&gt;CSS&lt;/span&gt;丢弃, 换成了bootstrap, 看起来&amp;nbsp;清爽多了&lt;/p&gt;
&lt;p&gt;但是, 上面的这个工程里面, 用的bootstrap版本太老, 是V1.4.0, 而bootstrap早就更新到2.0
以上了.本来&lt;span class=&#34;caps&#34;&gt;CSS&lt;/span&gt;这东西也没必要追求最新, 但是我发现了一个地方的&lt;span class=&#34;caps&#34;&gt;CSS&lt;/span&gt;很难看, 就是
&lt;code&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;...&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/code&gt;
这种格式, 这是Markdown在生成代码块的时候用的格式, 在这个&lt;span class=&#34;caps&#34;&gt;CSS&lt;/span&gt;上看起来, 文字底色是粉红
的,&amp;nbsp;很不协调.&lt;/p&gt;
&lt;p&gt;后来找到了一个解决的&lt;a href=&#34;https://github.com/twitter/bootstrap/issues/598&#34;&gt;方法&lt;/a&gt;,&amp;nbsp;测试下来也还可以&lt;/p&gt;
&lt;p&gt;然后不知道怎么搜的, 找到了&lt;a href=&#34;http://www.initializr.com/&#34;&gt;http://www.initializr.com/&lt;/a&gt;这个网站, 可以生成一套基本的
&lt;span class=&#34;caps&#34;&gt;HTML5&lt;/span&gt;+jQuery+bootstrap的模板, 于是我就让它给我生成了模板, 然后又是慢慢搞, 把原来的&amp;nbsp;模板替换掉.&lt;/p&gt;
&lt;p&gt;其实修改&lt;span class=&#34;caps&#34;&gt;CSS&lt;/span&gt;就是需要耐性, 在有了强大的Chrome的Developer Tools后, 所有的&lt;span class=&#34;caps&#34;&gt;CSS&lt;/span&gt;效果
都是&lt;span class=&#34;caps&#34;&gt;WYSIWYG&lt;/span&gt;, 只要调整到自己满意, 然后把代码复制下来,&amp;nbsp;写到&lt;span class=&#34;caps&#34;&gt;CSS&lt;/span&gt;文件里面即可&lt;/p&gt;
&lt;p&gt;bootstrap从1.4到2.0, 把code的样子改好看了, 另外一个row原来是分成16份, 现在是分成12.&amp;nbsp;还有导航栏的语法似乎也变掉了.&lt;/p&gt;
&lt;h3&gt;&lt;span class=&#34;caps&#34;&gt;CSS&lt;/span&gt;使用心得&lt;/h3&gt;
&lt;p&gt;Chrome已经内置了一个强大的网页调试工具, 无论调试js还是&lt;span class=&#34;caps&#34;&gt;CSS&lt;/span&gt;, 无论调试本地代码还是
观察服务器响应信息, 不论Debug还是Profile,&amp;nbsp;统统可以实现. &lt;/p&gt;
&lt;p&gt;之前写js时, 它展现了强大的断点调试和单步调试功能, 后来用Stylish插件时, 又表现了
完美的查找元素的功能. 这次我要调试&lt;span class=&#34;caps&#34;&gt;CSS&lt;/span&gt;,&amp;nbsp;又发现了它的&lt;span class=&#34;caps&#34;&gt;WYSIWYG&lt;/span&gt;也是那么强劲&lt;/p&gt;
&lt;p&gt;目前我对&lt;span class=&#34;caps&#34;&gt;CSS&lt;/span&gt;的理解是这样的(不一定正确,&amp;nbsp;仅供参考):&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;浏览器按照&lt;span class=&#34;caps&#34;&gt;HTML&lt;/span&gt;里面编写的顺序, 依次加载和解析&lt;span class=&#34;caps&#34;&gt;CSS&lt;/span&gt;, 如果有多个&lt;span class=&#34;caps&#34;&gt;CSS&lt;/span&gt;段匹配同一个
元素, 那么这些设置同时生效, 假设里面对同一个内容多次进行设置, 那么最后一个设置
有效. 利用这个特点, 一般把bootstrap写在前面, 然后再引用一个我们自己写的配置文件,&amp;nbsp;覆盖那些我们不太满意的地方&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;理解&lt;span class=&#34;caps&#34;&gt;CSS&lt;/span&gt;的&lt;a href=&#34;http://www.w3schools.com/css/css_boxmodel.asp&#34;&gt;盒子模型&lt;/a&gt;非常重要,
&lt;img alt=&#34;box model&#34; src=&#34;http://www.w3schools.com/css/box-model.gif&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有几个我觉得需要注意的地方:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个元素的width指的是content部分的宽度,不包括padding和border&lt;/li&gt;
&lt;li&gt;padding和border取负值没有意义,&amp;nbsp;按0算&lt;/li&gt;
&lt;li&gt;margin可以取负值, margin其实表示的是与父容器的相对位置, 比如margin-left就等于
&lt;code&gt;Px-x&lt;/code&gt;, 其中&lt;code&gt;x&lt;/code&gt;指本身border左上角的横坐标, &lt;code&gt;Px&lt;/code&gt;指父容器content部分左上角横坐标,
所以margin-left取负值时, 表示&lt;code&gt;x&amp;gt;Px&lt;/code&gt;,&amp;nbsp;也就是说这个元素的左边要突出父容器&lt;/li&gt;
&lt;li&gt;当父容器大小不够容纳这个元素的时候, 这个元素的范围会凸出去, 而且margin-right
可能会被舍弃(仅在Chrome中测试过,&amp;nbsp;其他浏览器未测试)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;浏览器兼容性&lt;/h3&gt;
&lt;p&gt;我只在我的Ubuntu的Google Chrome浏览器中测试了各种效果, 其他浏览器都没有怎么测试.
在一个Win7的&lt;span class=&#34;caps&#34;&gt;IE9&lt;/span&gt;上试过一下, 一开始是中文乱码, 后来加了一下charset的meta信息后, 
就可以正常显示了. 然后又发现Disqus在&lt;span class=&#34;caps&#34;&gt;IE9&lt;/span&gt;上显示不了, 经过一阵子的折腾, 没有找到
解决的办法,&amp;nbsp;暂时放弃.&lt;/p&gt;
&lt;p&gt;本来找的那个&lt;span class=&#34;caps&#34;&gt;HTML5&lt;/span&gt;模板上, 写了一些兼容老&lt;span class=&#34;caps&#34;&gt;IE&lt;/span&gt;浏览器的内容, 但是经过慎重考虑, 我决定
把大部分删掉, 就保留了一个提示升级浏览器的内容.&amp;nbsp;之所以这么做有两个原因&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;为了兼容老浏览器, 需要一些在线的js脚本, 这些脚本大部分是Google提供的, 由于
众所周知的原因, 这些内容很可能访问不了,&amp;nbsp;从而会导致页面载入的速度非常慢&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这个blog记录的绝大部分是技术内容, 如果一个喜欢技术的人, 是不可能一直用着古董
级别的&lt;span class=&#34;caps&#34;&gt;IE6&lt;/span&gt;, 这样的人不是我的目标读者, 所以也没必要为了他们让我去纠结半天. 其实我
甚至想直接不允许任何&lt;span class=&#34;caps&#34;&gt;IE&lt;/span&gt;用户访问, 毕竟即使是&lt;span class=&#34;caps&#34;&gt;IE9&lt;/span&gt;也有各种各样的毛病, 不过暂时还没
下手, 反正我肯定是不会在兼容&lt;span class=&#34;caps&#34;&gt;IE&lt;/span&gt;系的浏览器花时间的, &lt;span class=&#34;caps&#34;&gt;FF&lt;/span&gt;的兼容性有时间的话还是要研究&amp;nbsp;一下的.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;            </content>
        </entry>
            <entry>
            <title type="html">Bash常用命令</title>
            <author><name>newkedison</name></author>
            <link href="/blog/useful-bash-commands.html"/>
            <updated>2012-08-19T10:51:16Z</updated>
            <published>2012-08-19T10:51:16Z</published>
            <id>/blog/useful-bash-commands.html</id>
                        <category   scheme="/blog/tags"
                        term="bash"
                        label="Bash" />
                        <category   scheme="/blog/tags"
                        term="shell"
                        label="Shell" />
                        <category   scheme="/blog/tags"
                        term="command"
                        label="Command" />
            
            <content type="html">
                                &lt;h2&gt;带进度条复制文件&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ rsync -av --progress ~/Source ~/Dest
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;查看剩余空间&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ df
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;挂载Windows共享文件夹&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ mount -t cifs -o username=username,password=&#34;password&#34; //192.168.18.88/ShareFolderName /mnt/winshare
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;-t cifs&lt;/code&gt;制定挂载后等格式，据说这种格式效率比较高&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-o&lt;/code&gt;后面跟等设置，用都好分隔，用username制定登录用户名，用password制定密码，这个password记得用双引号，这样才能写特殊字符，password也可以不写，等会会提示输入。后面跟着等是远程路径，记得要写共享文件夹等名字，不然会出错的，最后一个参数就是挂载点&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;查看远程Windows主机共享了什么&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ smbclient -L //192.168.18.88 -U username
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;-U&lt;/code&gt;后面跟用户名，回车后会要求输入密码 &lt;/p&gt;
&lt;h2&gt;将当前文件夹下,所有文件中的common.h替换成Common.h&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ grep &#39;common.h&#39; *|awk -F: &#39;{print $1}&#39;|xargs sed -i &#39;/common.h/s//Common.h/&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;当前文件夹下的文件权限全部改为644&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ find . -type f -exec chmod 644 {} \;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;查看所有&lt;span class=&#34;caps&#34;&gt;TCP&lt;/span&gt;链接&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ netstat -npa --tcp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;-n&lt;/code&gt;表示不解析端口名,比如不加&lt;code&gt;-n&lt;/code&gt;时显示端口是&lt;span class=&#34;caps&#34;&gt;FTP&lt;/span&gt;,加上&lt;code&gt;-n&lt;/code&gt;后显示的就直接是端口号21,这个参数最好加上去,否则解析端口可能要占用很长的时间,而这几乎是没任何必要的,&lt;code&gt;-p&lt;/code&gt;要求显示进程名,方便用&lt;code&gt;grep&lt;/code&gt;找出需要的链接,&lt;code&gt;-a&lt;/code&gt;表示显示所有socket,如果不加上,只会显示已建立的链接,不会显示在监听的链接&lt;/p&gt;
&lt;h2&gt;VMWare切换到终端&lt;/h2&gt;
&lt;p&gt;从XWindow进入终端模式,本来是按Ctrl+Alt+Fn的,但是Ctrl+Alt是VMWare的快捷键,一种方法是修改VMWare的快捷键,另一种方法是先按住Ctrl和Fn,然后再按Alt&amp;nbsp;另外,从终端模式返回XWindow时按Alt+F7即可&lt;/p&gt;
&lt;h2&gt;获取当前runlevel&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ runlevel | tail -c 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;runlevel&lt;/code&gt;命令显示上一次和本次运行等级,显示格式如&amp;#8221;a b&amp;#8221;,如果要获取当前运行等级,那么用&lt;code&gt;tail&lt;/code&gt;命令,&lt;code&gt;-c&lt;/code&gt;参数表示获取最后N个字节,虽然我们只需要最后一个数字,但是参数要写2,可能是连结束符(或者换行符)也算上去了吧&lt;/p&gt;
&lt;h2&gt;查看系统日志&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ tail -f /var/log/syslog
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看系统日志文件的最后10行,而且程序不退出,一旦系统日志文件有更新,会追加显示,这样就可以用来监视系统日志了,当然,后面的文件名是任意的,也就是可以监视任意文件的变化&lt;/p&gt;
&lt;h2&gt;find不递归以及多条件&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ find . -maxdepth 1 -type f \( -name &#34;2*&#34; -or -name &#34;3*&#34; \) -exec echo {} \;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在当前文件夹下面搜索以2或者3开头的文件,并显示出来
&lt;code&gt;-maxdepth 1&lt;/code&gt; 使得find只在当前目录下查找,不深入文件夹,find在默认情况下,是递归搜索所有子文件夹的.注意这个选项要放在&lt;code&gt;-type&lt;/code&gt;前面,放在后面虽然也没问题,但是会有一个报警.
&lt;code&gt;-type f&lt;/code&gt; 指定只搜索文件,不管文件夹的名字是不是符合要求都忽略
后面用&lt;code&gt;\(&lt;/code&gt;和&lt;code&gt;\)&lt;/code&gt;括起来的是指定文件名,中间用一个&lt;code&gt;-or&lt;/code&gt;把两个条件&amp;#8221;或&amp;#8221;起来,注意要加上括号,但是括号前面要用反斜杠转义
最后执行一个echo命令,其实用&lt;code&gt;-print&lt;/code&gt;也是可以的&lt;/p&gt;
&lt;h2&gt;通过ssh拷贝远程Linux主机上的文件和文件夹&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ scp -p &amp;lt;login_name@hostname&amp;gt;:/dir/for/file localdir/to/filelocation
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;-p&lt;/code&gt;表示保留文件原来的修改时间， &lt;code&gt;&amp;lt;login_name@hostname&amp;gt;&lt;/code&gt;类似于newk@192.168.18.100，然后加上一个冒号再加上远程文件名，只要这个用户可以访问的文件，都可以复制，后面一个参数就是本地文件名
如果加上&lt;code&gt;-r&lt;/code&gt;参数，表示递归处理文件夹，不加上的话，所有文件夹将直接忽略&lt;/p&gt;
&lt;h2&gt;关于全局菜单栏上面的按钮会莫名其妙的丢失&lt;/h2&gt;
&lt;p&gt;先安装一个配置工具&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install dconf-tools
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ dconf-editor
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在弹出的“Configuration Editor”窗口中，依次点击左侧展开“desktop”&amp;gt;“unity”，点击选择“panel”（一定要点击一下，右边才有显示）&amp;nbsp;在右边Name下列出的“systray-whitelist”项目中，点击Value下的值，改为&amp;#8217;all&amp;#8217;即可&lt;/p&gt;
&lt;h2&gt;修改启动时启动的服务&lt;/h2&gt;
&lt;p&gt;下载rcconf&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install rcconf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后用sudo执行rcconf，可以看到配置界面，用方向键移动光标，用空格切换选中，用tab跳到确定&lt;/p&gt;
&lt;h2&gt;查看当前进程&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ ps auxf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以加上grep筛选出关注的进程&lt;/p&gt;
&lt;h2&gt;grep常用参数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;-m&amp;nbsp;1 &lt;/p&gt;
&lt;p&gt;在一个文件中，最多匹配一次，然后找下一个文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-A&amp;nbsp;2&lt;/p&gt;
&lt;p&gt;找到匹配后，除了显示匹配行，再显示该行前面的两行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-B&amp;nbsp;2&lt;/p&gt;
&lt;p&gt;找到匹配后，除了显示匹配行，再显示该行后面的两行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-I&lt;/p&gt;
&lt;p&gt;忽略二进制文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-r&lt;/p&gt;
&lt;p&gt;递归搜索所有子文件夹&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Shell脚本判断是否是被source&lt;/h2&gt;
&lt;p&gt;类似于python的if __name__ ==&amp;nbsp;&amp;#8220;__main__&amp;#8221;:，bash可以实现类似的功能，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; if [&lt;b&gt;&lt;/b&gt;[ &#34;$BASH_SOURCE&#34; == &#34;$0&#34; ]]; then
  main
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;产生随机数&lt;/h2&gt;
&lt;p&gt;在Linux里面，有两个特殊的设备/dev/random和/dev/urandom，可以用于产生随机数，可以&amp;nbsp;使用以下命令测试：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ od -vAn -N16 -w4 -tu4 &amp;lt; /dev/random
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先解释下od这个很好用的命令，这个命令是从文件读取指定长度的字节，然后按照一定的&amp;nbsp;规则，组合成数字进行输出，这在对付二进制文件的时候，非常的有用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-v&lt;/code&gt;这个参数我没测试出来作用，&lt;code&gt;-An&lt;/code&gt;表示不要打印地址，如果是&lt;code&gt;-Ax&lt;/code&gt;就是用十六进制
打印地址&amp;nbsp;这样在输出结果前面就会多出来一列地址。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-N16&lt;/code&gt;表示只读取16个字节&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-w4&lt;/code&gt;表示每4个字节作为一组，显示在一行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-t&lt;/code&gt;是决定按照什么格式来输出，&lt;code&gt;-tu4&lt;/code&gt;表示4字节的无符号整型，其他的格式参照man&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面的命令，就是从/dev/random读取16个字节，每4个字节1行，每4个字节组合成无符号&amp;nbsp;整型，然后输出&lt;/p&gt;
&lt;p&gt;从结果可以看到，生成了4个随机整数，但是，如果多次运行这个命令，可能会出现阻塞的&amp;nbsp;现象，这个时候，随便在键盘上乱按一些字符，就可以继续输出了。&lt;/p&gt;
&lt;p&gt;会出现阻塞的原因，是因为/dev/random是一个真正的随机数产生器，它的工作原理，是
不停的搜集系统内核中的环境噪声（其实就是按照一定的方法，从一些中断中获取随机信息
这些信息是随机产生的），然后在我们读取它的时候，就从它收集的信息中返回给我们随机
的字节，如果它没有收集到足够的信息，那么读取的时候就会发生阻塞，这时候我们从键盘&amp;nbsp;输入随机内容，其实就是产生了一些随机的环境噪声给它，这样它就能继续输出了。&lt;/p&gt;
&lt;p&gt;所以，/dev/random是一个真正的随机数产生器，与之相对应的，还有一个/dev/urandom
这个也可以产生随机数，但是在环境噪声不够的时候，不会阻塞，而是继续产生伪随机数&amp;nbsp;这样可以避免阻塞浪费大量的时间&lt;/p&gt;
&lt;p&gt;从使用场合来看，/dev/random适用于那些对安全性要求比较高的场合，而/dev/urandom在
平时的使用中，已经足够满足我们的使用需求了，至少比直接用时间作为随机种子要更加&amp;nbsp;随机一些。&lt;/p&gt;
&lt;p&gt;另外，如果在C程序中，就不要再用srand了，应该是先用fopen打开/dev/urandom，然后
fread需要的字节数直接到一个整型变量中，后面就可以根据需要获得指定范围内的随机数&amp;nbsp;最后别忘了fclose&lt;/p&gt;
&lt;h2&gt;pstree命令&lt;/h2&gt;
&lt;p&gt;这个命令用来查看一个进程的父进程，要比ps&amp;nbsp;auxf命令要清晰，格式很简单&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pstree -p | grep bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样可以查看所有含有bash的命令，已经他的父进程和子进程&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-p&lt;/code&gt;参数表示同时列出&lt;span class=&#34;caps&#34;&gt;PID&lt;/span&gt;，然后要kill还是要干嘛就方便了&lt;/p&gt;            </content>
        </entry>
            <entry>
            <title type="html">Markdown测试</title>
            <author><name>newkedison</name></author>
            <link href="/blog/test-markdown.html"/>
            <updated>2012-08-18T13:00:00Z</updated>
            <published>2012-08-18T13:00:00Z</published>
            <id>/blog/test-markdown.html</id>
                        <category   scheme="/blog/tags"
                        term="post"
                        label="Post" />
                        <category   scheme="/blog/tags"
                        term="test"
                        label="Test" />
                        <category   scheme="/blog/tags"
                        term="markdown"
                        label="Markdown" />
            
            <content type="html">
                                &lt;h1&gt;Test Markdown&amp;nbsp;syntax&lt;/h1&gt;
&lt;h2&gt;level 2&amp;nbsp;title&lt;/h2&gt;
&lt;h3&gt;level 3&amp;nbsp;title&lt;/h3&gt;
&lt;h4&gt;level 4&amp;nbsp;title&lt;/h4&gt;
&lt;h5&gt;level 5&amp;nbsp;title&lt;/h5&gt;
&lt;h6&gt;level 6&amp;nbsp;title&lt;/h6&gt;
&lt;p&gt;连续多行内容
会被认为是连续的,
放在一对&amp;lt;P&amp;gt;&amp;lt;/P&amp;gt;里面,&amp;nbsp;如果要分段,至少留一个空行&lt;/p&gt;
&lt;p&gt;有另一种办法&lt;br /&gt;
就是在行末添加两个空格&lt;br /&gt;
这样会被替换为&amp;lt;br&amp;nbsp;/&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以直接写&lt;em&gt;&lt;span class=&#34;caps&#34;&gt;HTML&lt;/span&gt;&lt;/em&gt;,&amp;nbsp;而且4&amp;lt;5这种写法是没问题的&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;引用内容前面用一个大于号即可&lt;br /&gt;
每一段内容只要第一行有一个大于号就可以了&lt;br /&gt;
但是为了美观,&amp;nbsp;最好还是每一行前面一个大于号&lt;/p&gt;
&lt;p&gt;引用可以嵌套&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;只要多加一个大于号即可&amp;nbsp;而且可以内嵌其他语法,比如 &lt;/p&gt;
&lt;h2&gt;标题2&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;h3&gt;标题3&lt;/h3&gt;
&lt;/blockquote&gt;
&lt;p&gt;列表分为有序列表和无序列表&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无序列表前面可以是星号&lt;/li&gt;
&lt;li&gt;加号&lt;/li&gt;
&lt;li&gt;或者减号&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有序列表前面是数字加一个小数点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以是任意数字&lt;/li&gt;
&lt;li&gt;不影响最后的结果&lt;/li&gt;
&lt;li&gt;数字之间不论任何大小关系都可以&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;要结束一个列表,需要一行非列表的内容&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果列表要有多段&lt;/p&gt;
&lt;p&gt;后面的段要缩进4个空格或者一个Tab&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只要每一段的第一行缩进即可&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1111.&amp;nbsp;有些时候为了避免数字被解析为列表,需要在小数点前面加上反斜杠进行转义&lt;/p&gt;
&lt;p&gt;代码段用4空格缩进来表示,比如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int main(int argc, const char* argv[])
{
  printf(&#34;hello world&#34;);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码段中的全部内容会保留原样不变,除了一开始的4个空格被移除外,所有缩进也都保留&lt;/p&gt;
&lt;hr /&gt;
&lt;hr /&gt;
&lt;hr /&gt;
&lt;p&gt;三个或更多的等号和星号,可以变成一根横线,中间可以有任意个空格&lt;/p&gt;
&lt;p&gt;超链接有三种写法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;行内链接&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.google.com&#34; title=&#34;这里是title属性&#34;&gt;google&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;引用链接&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.google.com&#34; title=&#34;这个title可以单引号,双引号,圆括号包围&#34;&gt;google&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;简单写法&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.google.com&#34;&gt;http://www.google.com&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;*或者_用来表示强调,前后各&lt;em&gt;一个&lt;/em&gt;会替换为&lt;em&gt;em(斜体)&lt;/em&gt;(测试下来好像只有星号有用),
前后各&lt;strong&gt;两个&lt;/strong&gt;会替换为&lt;strong&gt;strong&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;行内内嵌代码块, 可以使用反引号, 例如&lt;code&gt;printf()&lt;/code&gt;&lt;/p&gt;            </content>
        </entry>
    </feed>