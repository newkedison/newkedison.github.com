<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>
        BASIC blog full text feed    </title>
        <link href="blog/atom.xml" rel="self" />
    
        <link href="/"/>
    
        
    <updated>2012-08-21T13:34:24Z</updated>

    <id>/blog/atom.xml/</id>

            <entry>
            <title type="html">使用Hyde建立静态网站</title>
            <author><name>newkedison</name></author>
            <link href="/blog/how-to-use-hyde.html"/>
            <updated>2012-08-19T10:51:16Z</updated>
            <published>2012-08-19T10:51:16Z</published>
            <id>/blog/how-to-use-hyde.html</id>
                        <category   scheme="/blog/tags"
                        term="hyde"
                        label="Hyde" />
                        <category   scheme="/blog/tags"
                        term="github"
                        label="Github" />
            
            <content type="html">
                                &lt;h6&gt;想到什么写什么, 暂时比较混乱,&amp;nbsp;等写完再整理&lt;/h6&gt;
&lt;h3&gt;hyde对jinja2的扩展&lt;/h3&gt;
&lt;p&gt;hyde号称支持多种模板系统, 但是目前仅支持jinja2, 这是一种与Django模板语法很类似的
模板系统,&amp;nbsp;这也是我选择hyde而不是JekyII的原因&lt;/p&gt;
&lt;p&gt;但是, hyde对jinja2进行了一些扩展, 导致我在看代码的时候, 碰到看不懂的地方去查
jinja2&amp;nbsp;的文档总是找不到说明&lt;/p&gt;
&lt;p&gt;下面列举目前我知道的hyde对jinja的扩展&lt;/p&gt;
&lt;h4&gt;filter(过滤器)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;{% content|markdow %}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;对content的内容按照markdown语法进行解析&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;{% content|typogrify %}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;对content的内容进行一些&amp;#8221;美化&amp;#8221;(我个人不认为很美), 
可参考&lt;a href=&#34;http://code.google.com/p/typogrify/&#34;&gt;这里&lt;/a&gt;的说明
(还有&lt;a href=&#34;http://static.mintchaos.com/projects/typogrify/&#34;&gt;demo&lt;/a&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;mark&amp;nbsp;tag(标记)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;{% mark name -%}...{%- endmark %}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个我还不知道干嘛用的,&amp;nbsp;可能需要和下面的refer配套使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;{% refer to XXX as YYY %}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个的具体用法也还没明白&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;替换网页模板&lt;/h3&gt;
&lt;p&gt;原来的模板比较难看, 我不得不换一个模板, 自己写一个模板就比较复杂了, 但是其实原来的
模板主要是&lt;span class=&#34;caps&#34;&gt;CSS&lt;/span&gt;比较难看,&amp;nbsp;于是主要工作变成了换&lt;span class=&#34;caps&#34;&gt;CSS&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;刚好前阵子稍微学习了一下bootstrap, 于是当然是换成整套的bootstrap, 在hyde的Github
主页上, 给了一个使用bootstrap的项目(见
&lt;a href=&#34;https://github.com/auzigog/hyde-bootstrap&#34;&gt;hyde-bootstrap&lt;/a&gt;)
于是我下载了压缩包, 然后把&lt;span class=&#34;caps&#34;&gt;CSS&lt;/span&gt;和js都弄过来, 接着修改layout文件夹里面几个模板文件的
内容, 慢慢调试(这其实就是个耐心活), 最后终于把原来的&lt;span class=&#34;caps&#34;&gt;CSS&lt;/span&gt;丢弃, 换成了bootstrap, 看起来&amp;nbsp;清爽多了&lt;/p&gt;
&lt;p&gt;但是, 上面的这个工程里面, 用的bootstrap版本太老, 是V1.4.0, 而bootstrap早就更新到2.0
以上了.本来&lt;span class=&#34;caps&#34;&gt;CSS&lt;/span&gt;这东西也没必要追求最新, 但是我发现了一个地方的&lt;span class=&#34;caps&#34;&gt;CSS&lt;/span&gt;很难看, 就是
&lt;code&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;...&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/code&gt;
这种格式, 这是Markdown在生成代码块的时候用的格式, 在这个&lt;span class=&#34;caps&#34;&gt;CSS&lt;/span&gt;上看起来, 文字底色是粉红
的,&amp;nbsp;很不协调.&lt;/p&gt;
&lt;p&gt;后来找到了一个解决的&lt;a href=&#34;https://github.com/twitter/bootstrap/issues/598&#34;&gt;方法&lt;/a&gt;,&amp;nbsp;测试下来也还可以&lt;/p&gt;
&lt;p&gt;然后不知道怎么搜的, 找到了&lt;a href=&#34;http://www.initializr.com/&#34;&gt;http://www.initializr.com/&lt;/a&gt;这个网站, 可以生成一套基本的
&lt;span class=&#34;caps&#34;&gt;HTML5&lt;/span&gt;+jQuery+bootstrap的模板, 于是我就让它给我生成了模板, 然后又是慢慢搞, 把原来的&amp;nbsp;模板替换掉.&lt;/p&gt;
&lt;p&gt;其实修改&lt;span class=&#34;caps&#34;&gt;CSS&lt;/span&gt;就是需要耐性, 在有了强大的Chrome的Developer Tools后, 所有的&lt;span class=&#34;caps&#34;&gt;CSS&lt;/span&gt;效果
都是&lt;span class=&#34;caps&#34;&gt;WYSIWYG&lt;/span&gt;, 只要调整到自己满意, 然后把代码复制下来,&amp;nbsp;写到&lt;span class=&#34;caps&#34;&gt;CSS&lt;/span&gt;文件里面即可&lt;/p&gt;
&lt;p&gt;bootstrap从1.4到2.0, 把code的样子改好看了, 另外一个row原来是分成16份, 现在是分成12.&amp;nbsp;还有导航栏的语法似乎也变掉了.&lt;/p&gt;
&lt;h3&gt;&lt;span class=&#34;caps&#34;&gt;CSS&lt;/span&gt;使用心得&lt;/h3&gt;
&lt;p&gt;Chrome已经内置了一个强大的网页调试工具, 无论调试js还是&lt;span class=&#34;caps&#34;&gt;CSS&lt;/span&gt;, 无论调试本地代码还是
观察服务器响应信息, 不论Debug还是Profile,&amp;nbsp;统统可以实现. &lt;/p&gt;
&lt;p&gt;之前写js时, 它展现了强大的断点调试和单步调试功能, 后来用Stylish插件时, 又表现了
完美的查找元素的功能. 这次我要调试&lt;span class=&#34;caps&#34;&gt;CSS&lt;/span&gt;,&amp;nbsp;又发现了它的&lt;span class=&#34;caps&#34;&gt;WYSIWYG&lt;/span&gt;也是那么强劲&lt;/p&gt;
&lt;p&gt;目前我对&lt;span class=&#34;caps&#34;&gt;CSS&lt;/span&gt;的理解是这样的(不一定正确,&amp;nbsp;仅供参考):&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;浏览器按照&lt;span class=&#34;caps&#34;&gt;HTML&lt;/span&gt;里面编写的顺序, 依次加载和解析&lt;span class=&#34;caps&#34;&gt;CSS&lt;/span&gt;, 如果有多个&lt;span class=&#34;caps&#34;&gt;CSS&lt;/span&gt;段匹配同一个
元素, 那么这些设置同时生效, 假设里面对同一个内容多次进行设置, 那么最后一个设置
有效. 利用这个特点, 一般把bootstrap写在前面, 然后再引用一个我们自己写的配置文件,&amp;nbsp;覆盖那些我们不太满意的地方&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;理解&lt;span class=&#34;caps&#34;&gt;CSS&lt;/span&gt;的&lt;a href=&#34;http://www.w3schools.com/css/css_boxmodel.asp&#34;&gt;盒子模型&lt;/a&gt;非常重要,
&lt;img alt=&#34;box model&#34; src=&#34;http://www.w3schools.com/css/box-model.gif&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有几个我觉得需要注意的地方:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个元素的width指的是content部分的宽度,不包括padding和border&lt;/li&gt;
&lt;li&gt;padding和border取负值没有意义,&amp;nbsp;按0算&lt;/li&gt;
&lt;li&gt;margin可以取负值, margin其实表示的是与父容器的相对位置, 比如margin-left就等于
&lt;code&gt;Px-x&lt;/code&gt;, 其中&lt;code&gt;x&lt;/code&gt;指本身border左上角的横坐标, &lt;code&gt;Px&lt;/code&gt;指父容器content部分左上角横坐标,
所以margin-left取负值时, 表示&lt;code&gt;x&amp;gt;Px&lt;/code&gt;,&amp;nbsp;也就是说这个元素的左边要突出父容器&lt;/li&gt;
&lt;li&gt;当父容器大小不够容纳这个元素的时候, 这个元素的范围会凸出去, 而且margin-right
可能会被舍弃(仅在Chrome中测试过,&amp;nbsp;其他浏览器未测试)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;浏览器兼容性&lt;/h3&gt;
&lt;p&gt;我只在我的Ubuntu的Google Chrome浏览器中测试了各种效果, 其他浏览器都没有怎么测试.
在一个Win7的&lt;span class=&#34;caps&#34;&gt;IE9&lt;/span&gt;上试过一下, 一开始是中文乱码, 后来加了一下charset的meta信息后, 
就可以正常显示了. 然后又发现Disqus在&lt;span class=&#34;caps&#34;&gt;IE9&lt;/span&gt;上显示不了, 经过一阵子的折腾, 没有找到
解决的办法,&amp;nbsp;暂时放弃.&lt;/p&gt;
&lt;p&gt;本来找的那个&lt;span class=&#34;caps&#34;&gt;HTML5&lt;/span&gt;模板上, 写了一些兼容老&lt;span class=&#34;caps&#34;&gt;IE&lt;/span&gt;浏览器的内容, 但是经过慎重考虑, 我决定
把大部分删掉, 就保留了一个提示升级浏览器的内容.&amp;nbsp;之所以这么做有两个原因&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;为了兼容老浏览器, 需要一些在线的js脚本, 这些脚本大部分是Google提供的, 由于
众所周知的原因, 这些内容很可能访问不了,&amp;nbsp;从而会导致页面载入的速度非常慢&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这个blog记录的绝大部分是技术内容, 如果一个喜欢技术的人, 是不可能一直用着古董
级别的&lt;span class=&#34;caps&#34;&gt;IE6&lt;/span&gt;, 这样的人不是我的目标读者, 所以也没必要为了他们让我去纠结半天. 其实我
甚至想直接不允许任何&lt;span class=&#34;caps&#34;&gt;IE&lt;/span&gt;用户访问, 毕竟即使是&lt;span class=&#34;caps&#34;&gt;IE9&lt;/span&gt;也有各种各样的毛病, 不过暂时还没
下手, 反正我肯定是不会在兼容&lt;span class=&#34;caps&#34;&gt;IE&lt;/span&gt;系的浏览器花时间的, &lt;span class=&#34;caps&#34;&gt;FF&lt;/span&gt;的兼容性有时间的话还是要研究&amp;nbsp;一下的.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;            </content>
        </entry>
            <entry>
            <title type="html">Markdown测试</title>
            <author><name>newkedison</name></author>
            <link href="/blog/test-markdown.html"/>
            <updated>2012-08-18T13:00:00Z</updated>
            <published>2012-08-18T13:00:00Z</published>
            <id>/blog/test-markdown.html</id>
                        <category   scheme="/blog/tags"
                        term="post"
                        label="Post" />
                        <category   scheme="/blog/tags"
                        term="test"
                        label="Test" />
                        <category   scheme="/blog/tags"
                        term="markdown"
                        label="Markdown" />
            
            <content type="html">
                                &lt;h1&gt;Test Markdown&amp;nbsp;syntax&lt;/h1&gt;
&lt;h2&gt;level 2&amp;nbsp;title&lt;/h2&gt;
&lt;h3&gt;level 3&amp;nbsp;title&lt;/h3&gt;
&lt;h4&gt;level 4&amp;nbsp;title&lt;/h4&gt;
&lt;h5&gt;level 5&amp;nbsp;title&lt;/h5&gt;
&lt;h6&gt;level 6&amp;nbsp;title&lt;/h6&gt;
&lt;p&gt;连续多行内容
会被认为是连续的,
放在一对&amp;lt;P&amp;gt;&amp;lt;/P&amp;gt;里面,&amp;nbsp;如果要分段,至少留一个空行&lt;/p&gt;
&lt;p&gt;有另一种办法&lt;br /&gt;
就是在行末添加两个空格&lt;br /&gt;
这样会被替换为&amp;lt;br&amp;nbsp;/&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以直接写&lt;em&gt;&lt;span class=&#34;caps&#34;&gt;HTML&lt;/span&gt;&lt;/em&gt;,&amp;nbsp;而且4&amp;lt;5这种写法是没问题的&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;引用内容前面用一个大于号即可&lt;br /&gt;
每一段内容只要第一行有一个大于号就可以了&lt;br /&gt;
但是为了美观,&amp;nbsp;最好还是每一行前面一个大于号&lt;/p&gt;
&lt;p&gt;引用可以嵌套&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;只要多加一个大于号即可&amp;nbsp;而且可以内嵌其他语法,比如 &lt;/p&gt;
&lt;h2&gt;标题2&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;h3&gt;标题3&lt;/h3&gt;
&lt;/blockquote&gt;
&lt;p&gt;列表分为有序列表和无序列表&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无序列表前面可以是星号&lt;/li&gt;
&lt;li&gt;加号&lt;/li&gt;
&lt;li&gt;或者减号&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有序列表前面是数字加一个小数点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以是任意数字&lt;/li&gt;
&lt;li&gt;不影响最后的结果&lt;/li&gt;
&lt;li&gt;数字之间不论任何大小关系都可以&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;要结束一个列表,需要一行非列表的内容&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果列表要有多段&lt;/p&gt;
&lt;p&gt;后面的段要缩进4个空格或者一个Tab&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只要每一段的第一行缩进即可&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1111.&amp;nbsp;有些时候为了避免数字被解析为列表,需要在小数点前面加上反斜杠进行转义&lt;/p&gt;
&lt;p&gt;代码段用4空格缩进来表示,比如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int main(int argc, const char* argv[])
{
  printf(&#34;hello world&#34;);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码段中的全部内容会保留原样不变,除了一开始的4个空格被移除外,所有缩进也都保留&lt;/p&gt;
&lt;hr /&gt;
&lt;hr /&gt;
&lt;hr /&gt;
&lt;p&gt;三个或更多的等号和星号,可以变成一根横线,中间可以有任意个空格&lt;/p&gt;
&lt;p&gt;超链接有三种写法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;行内链接&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.google.com&#34; title=&#34;这里是title属性&#34;&gt;google&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;引用链接&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.google.com&#34; title=&#34;这个title可以单引号,双引号,圆括号包围&#34;&gt;google&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;简单写法&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.google.com&#34;&gt;http://www.google.com&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;*或者_用来表示强调,前后各&lt;em&gt;一个&lt;/em&gt;会替换为&lt;em&gt;em(斜体)&lt;/em&gt;(测试下来好像只有星号有用),
前后各&lt;strong&gt;两个&lt;/strong&gt;会替换为&lt;strong&gt;strong&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;行内内嵌代码块, 可以使用反引号, 例如&lt;code&gt;printf()&lt;/code&gt;&lt;/p&gt;            </content>
        </entry>
            <entry>
            <title type="html">Bash常用命令</title>
            <author><name>newkedison</name></author>
            <link href="/blog/useful-bash-commands.html"/>
            <updated>2012-01-14T18:18:15Z</updated>
            <published>2012-01-14T18:18:15Z</published>
            <id>/blog/useful-bash-commands.html</id>
                        <category   scheme="/blog/tags"
                        term="bash"
                        label="Bash" />
                        <category   scheme="/blog/tags"
                        term="shell"
                        label="Shell" />
                        <category   scheme="/blog/tags"
                        term="command"
                        label="Command" />
            
            <content type="html">
                                &lt;h2&gt;带进度条复制文件&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ rsync -av --progress ~/Source ~/Dest
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;查看剩余空间&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ df
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;挂载Windows共享文件夹&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ mount -t cifs -o username=username,password=&#34;password&#34; //192.168.18.88/ShareFolderName /mnt/winshare
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;-t cifs&lt;/code&gt;制定挂载后等格式，据说这种格式效率比较高&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-o&lt;/code&gt;后面跟等设置，用都好分隔，用username制定登录用户名，用password制定密码，这个password记得用双引号，这样才能写特殊字符，password也可以不写，等会会提示输入。后面跟着等是远程路径，记得要写共享文件夹等名字，不然会出错的，最后一个参数就是挂载点&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;查看远程Windows主机共享了什么&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ smbclient -L //192.168.18.88 -U username
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;-U&lt;/code&gt;后面跟用户名，回车后会要求输入密码 &lt;/p&gt;
&lt;h2&gt;将当前文件夹下,所有文件中的common.h替换成Common.h&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ grep &#39;common.h&#39; *|awk -F: &#39;{print $1}&#39;|xargs sed -i &#39;/common.h/s//Common.h/&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;当前文件夹下的文件权限全部改为644&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ find . -type f -exec chmod 644 {} \;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;查看所有&lt;span class=&#34;caps&#34;&gt;TCP&lt;/span&gt;链接&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ netstat -npa --tcp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;-n&lt;/code&gt;表示不解析端口名,比如不加&lt;code&gt;-n&lt;/code&gt;时显示端口是&lt;span class=&#34;caps&#34;&gt;FTP&lt;/span&gt;,加上&lt;code&gt;-n&lt;/code&gt;后显示的就直接是端口号21,这个参数最好加上去,否则解析端口可能要占用很长的时间,而这几乎是没任何必要的,&lt;code&gt;-p&lt;/code&gt;要求显示进程名,方便用&lt;code&gt;grep&lt;/code&gt;找出需要的链接,&lt;code&gt;-a&lt;/code&gt;表示显示所有socket,如果不加上,只会显示已建立的链接,不会显示在监听的链接&lt;/p&gt;
&lt;h2&gt;VMWare切换到终端&lt;/h2&gt;
&lt;p&gt;从XWindow进入终端模式,本来是按Ctrl+Alt+Fn的,但是Ctrl+Alt是VMWare的快捷键,一种方法是修改VMWare的快捷键,另一种方法是先按住Ctrl和Fn,然后再按Alt&amp;nbsp;另外,从终端模式返回XWindow时按Alt+F7即可&lt;/p&gt;
&lt;h2&gt;获取当前runlevel&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ runlevel | tail -c 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;runlevel&lt;/code&gt;命令显示上一次和本次运行等级,显示格式如&amp;#8221;a b&amp;#8221;,如果要获取当前运行等级,那么用&lt;code&gt;tail&lt;/code&gt;命令,&lt;code&gt;-c&lt;/code&gt;参数表示获取最后N个字节,虽然我们只需要最后一个数字,但是参数要写2,可能是连结束符(或者换行符)也算上去了吧&lt;/p&gt;
&lt;h2&gt;查看系统日志&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ tail -f /var/log/syslog
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看系统日志文件的最后10行,而且程序不退出,一旦系统日志文件有更新,会追加显示,这样就可以用来监视系统日志了,当然,后面的文件名是任意的,也就是可以监视任意文件的变化&lt;/p&gt;
&lt;h2&gt;find不递归以及多条件&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ find . -maxdepth 1 -type f \( -name &#34;2*&#34; -or -name &#34;3*&#34; \) -exec echo {} \;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在当前文件夹下面搜索以2或者3开头的文件,并显示出来
&lt;code&gt;-maxdepth 1&lt;/code&gt; 使得find只在当前目录下查找,不深入文件夹,find在默认情况下,是递归搜索所有子文件夹的.注意这个选项要放在&lt;code&gt;-type&lt;/code&gt;前面,放在后面虽然也没问题,但是会有一个报警.
&lt;code&gt;-type f&lt;/code&gt; 指定只搜索文件,不管文件夹的名字是不是符合要求都忽略
后面用&lt;code&gt;\(&lt;/code&gt;和&lt;code&gt;\)&lt;/code&gt;括起来的是指定文件名,中间用一个&lt;code&gt;-or&lt;/code&gt;把两个条件&amp;#8221;或&amp;#8221;起来,注意要加上括号,但是括号前面要用反斜杠转义
最后执行一个echo命令,其实用&lt;code&gt;-print&lt;/code&gt;也是可以的&lt;/p&gt;
&lt;h2&gt;通过ssh拷贝远程Linux主机上的文件和文件夹&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ scp -p &amp;lt;login_name@hostname&amp;gt;:/dir/for/file localdir/to/filelocation
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;-p&lt;/code&gt;表示保留文件原来的修改时间， &lt;code&gt;&amp;lt;login_name@hostname&amp;gt;&lt;/code&gt;类似于newk@192.168.18.100，然后加上一个冒号再加上远程文件名，只要这个用户可以访问的文件，都可以复制，后面一个参数就是本地文件名
如果加上&lt;code&gt;-r&lt;/code&gt;参数，表示递归处理文件夹，不加上的话，所有文件夹将直接忽略&lt;/p&gt;
&lt;h2&gt;关于全局菜单栏上面的按钮会莫名其妙的丢失&lt;/h2&gt;
&lt;p&gt;先安装一个配置工具&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install dconf-tools
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ dconf-editor
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在弹出的“Configuration Editor”窗口中，依次点击左侧展开“desktop”&amp;gt;“unity”，点击选择“panel”（一定要点击一下，右边才有显示）&amp;nbsp;在右边Name下列出的“systray-whitelist”项目中，点击Value下的值，改为&amp;#8217;all&amp;#8217;即可&lt;/p&gt;
&lt;h2&gt;修改启动时启动的服务&lt;/h2&gt;
&lt;p&gt;下载rcconf&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install rcconf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后用sudo执行rcconf，可以看到配置界面，用方向键移动光标，用空格切换选中，用tab跳到确定&lt;/p&gt;
&lt;h2&gt;查看当前进程&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ ps auxf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以加上grep筛选出关注的进程&lt;/p&gt;
&lt;h2&gt;grep常用参数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;-m&amp;nbsp;1 &lt;/p&gt;
&lt;p&gt;在一个文件中，最多匹配一次，然后找下一个文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-A&amp;nbsp;2&lt;/p&gt;
&lt;p&gt;找到匹配后，除了显示匹配行，再显示该行前面的两行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-B&amp;nbsp;2&lt;/p&gt;
&lt;p&gt;找到匹配后，除了显示匹配行，再显示该行后面的两行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-I&lt;/p&gt;
&lt;p&gt;忽略二进制文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-r&lt;/p&gt;
&lt;p&gt;递归搜索所有子文件夹&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Shell脚本判断是否是被source&lt;/h2&gt;
&lt;p&gt;类似于python的if __name__ ==&amp;nbsp;&amp;#8220;__main__&amp;#8221;:，bash可以实现类似的功能，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; if [&lt;b&gt;&lt;/b&gt;[ &#34;$BASH_SOURCE&#34; == &#34;$0&#34; ]]; then
  main
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;产生随机数&lt;/h2&gt;
&lt;p&gt;在Linux里面，有两个特殊的设备/dev/random和/dev/urandom，可以用于产生随机数，可以&amp;nbsp;使用以下命令测试：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ od -vAn -N16 -w4 -tu4 &amp;lt; /dev/random
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先解释下od这个很好用的命令，这个命令是从文件读取指定长度的字节，然后按照一定的&amp;nbsp;规则，组合成数字进行输出，这在对付二进制文件的时候，非常的有用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-v&lt;/code&gt;这个参数我没测试出来作用，&lt;code&gt;-An&lt;/code&gt;表示不要打印地址，如果是&lt;code&gt;-Ax&lt;/code&gt;就是用十六进制
打印地址&amp;nbsp;这样在输出结果前面就会多出来一列地址。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-N16&lt;/code&gt;表示只读取16个字节&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-w4&lt;/code&gt;表示每4个字节作为一组，显示在一行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-t&lt;/code&gt;是决定按照什么格式来输出，&lt;code&gt;-tu4&lt;/code&gt;表示4字节的无符号整型，其他的格式参照man&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面的命令，就是从/dev/random读取16个字节，每4个字节1行，每4个字节组合成无符号&amp;nbsp;整型，然后输出&lt;/p&gt;
&lt;p&gt;从结果可以看到，生成了4个随机整数，但是，如果多次运行这个命令，可能会出现阻塞的&amp;nbsp;现象，这个时候，随便在键盘上乱按一些字符，就可以继续输出了。&lt;/p&gt;
&lt;p&gt;会出现阻塞的原因，是因为/dev/random是一个真正的随机数产生器，它的工作原理，是
不停的搜集系统内核中的环境噪声（其实就是按照一定的方法，从一些中断中获取随机信息
这些信息是随机产生的），然后在我们读取它的时候，就从它收集的信息中返回给我们随机
的字节，如果它没有收集到足够的信息，那么读取的时候就会发生阻塞，这时候我们从键盘&amp;nbsp;输入随机内容，其实就是产生了一些随机的环境噪声给它，这样它就能继续输出了。&lt;/p&gt;
&lt;p&gt;所以，/dev/random是一个真正的随机数产生器，与之相对应的，还有一个/dev/urandom
这个也可以产生随机数，但是在环境噪声不够的时候，不会阻塞，而是继续产生伪随机数&amp;nbsp;这样可以避免阻塞浪费大量的时间&lt;/p&gt;
&lt;p&gt;从使用场合来看，/dev/random适用于那些对安全性要求比较高的场合，而/dev/urandom在
平时的使用中，已经足够满足我们的使用需求了，至少比直接用时间作为随机种子要更加&amp;nbsp;随机一些。&lt;/p&gt;
&lt;p&gt;另外，如果在C程序中，就不要再用srand了，应该是先用fopen打开/dev/urandom，然后
fread需要的字节数直接到一个整型变量中，后面就可以根据需要获得指定范围内的随机数&amp;nbsp;最后别忘了fclose&lt;/p&gt;
&lt;h2&gt;pstree命令&lt;/h2&gt;
&lt;p&gt;这个命令用来查看一个进程的父进程，要比ps&amp;nbsp;auxf命令要清晰，格式很简单&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pstree -p | grep bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样可以查看所有含有bash的命令，已经他的父进程和子进程&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-p&lt;/code&gt;参数表示同时列出&lt;span class=&#34;caps&#34;&gt;PID&lt;/span&gt;，然后要kill还是要干嘛就方便了&lt;/p&gt;            </content>
        </entry>
            <entry>
            <title type="html">Python小知识</title>
            <author><name>newkedison</name></author>
            <link href="/blog/tips-for-python.html"/>
            <updated>2011-12-07T15:13:40Z</updated>
            <published>2011-12-07T15:13:40Z</published>
            <id>/blog/tips-for-python.html</id>
                        <category   scheme="/blog/tags"
                        term="python"
                        label="Python" />
                        <category   scheme="/blog/tags"
                        term="tips"
                        label="Tips" />
            
            <content type="html">
                                &lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;type(10) == types.IntType&lt;/code&gt; 与 &lt;code&gt;type(10) is types.IntType&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这两句的结果是一致的,&amp;nbsp;但是思路不同&lt;/p&gt;
&lt;p&gt;首先要明确, &lt;code&gt;type&lt;/code&gt;的返回值是一个&amp;#8221;类型&amp;#8221;(也可以说是&amp;#8221;类&amp;#8221;, 因为从Python2.2开始, 
这两者已经统一了), &lt;code&gt;types.IntType&lt;/code&gt;也是一个&amp;#8221;类型&amp;#8221;&lt;/p&gt;
&lt;p&gt;其次, 两个类型在比较, 如果用==, 那么比较的是类型的值, 如果用&lt;code&gt;is&lt;/code&gt;, 
比较的是是否指向同一个对象.可以这么理解, 如果用==, 是对整个类进行比较, 
如果用&lt;code&gt;is&lt;/code&gt;, 是比较地址是否相等.显而易见, 比较地址的效率肯定是高的
(另: &lt;code&gt;X is Y&lt;/code&gt;等价于&lt;code&gt;id(X)==id(Y)&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;再次, 因为&lt;code&gt;type&lt;/code&gt;的返回值都是类型(类型的&lt;code&gt;__name__&lt;/code&gt;就叫&lt;code&gt;type&lt;/code&gt;), 
这种类型总共就那么几个值, 这些值都是&lt;code&gt;types&lt;/code&gt;这个模块里面.
用一个小实验(&lt;code&gt;id(type(10)==id(types.IntType)&lt;/code&gt;的结果为True), 就可以看出, 
实际上&lt;code&gt;type&lt;/code&gt;返回值, 就是&lt;code&gt;types&lt;/code&gt;模块中几个类型的引用.&lt;/p&gt;
&lt;p&gt;那么, 就可以用&lt;code&gt;is&lt;/code&gt;直接判断&lt;code&gt;type&lt;/code&gt;的返回值,&amp;nbsp;这样的效率比==要高一些&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;enumerate()&lt;/code&gt;这个函数在for循环中很好用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a=(1, 22, 333, 444)
for i, value in enumerate(a)
    print &#39;(%d)%d&#39; % i % value
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样在循环中, 可以同时取出数值和序号, 不用自己定义一个变量,&amp;nbsp;用来算序号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调试wxPython程序时, 由于错误信息已经给重定向了, 导致代码有错误时, 会一闪而过,
解决的方法, 就是在定义App实例时, 设置参数&lt;code&gt;redirect=True&lt;/code&gt;, 这样就能看到错误提示了.
注意, 如果继承了wx.App, 那么是在调用父类的&lt;code&gt;__init__&lt;/code&gt;中设置这个参数.&lt;/p&gt;
&lt;p&gt;另外, 在Windows中, &lt;code&gt;redirect&lt;/code&gt;的默认值是True, 而在Linux/Unit中, 默认值是False, 
所以最好手动赋值一下,&amp;nbsp;以免换平台时出错&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;继承一个类之后, 如果不重定义&lt;code&gt;__init__&lt;/code&gt;函数, 那么父类的&lt;code&gt;__init__&lt;/code&gt;会被自动调用,
如果重定义了&lt;code&gt;__init__&lt;/code&gt;, 那么一定要记得在这个函数里面调用父类的&lt;code&gt;__init__&lt;/code&gt;, 
因为Python不像C++, 他不会再自动调用父类的&lt;code&gt;__init__&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;判断一个变量是否已经定义，有三种方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一种方法：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;quo&#34;&gt;&amp;#8216;&lt;/span&gt;var&amp;#8217; in&amp;nbsp;locals().keys()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二种方法：&lt;/p&gt;
&lt;p&gt;try: 
  print var
except NameError: 
  print &amp;#8216;var not&amp;nbsp;defined&amp;#8217;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三种方法：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;quo&#34;&gt;&amp;#8216;&lt;/span&gt;var&amp;#8217; in&amp;nbsp;dir()&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关于&lt;span class=&#34;caps&#34;&gt;PEP8&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;caps&#34;&gt;PEP8&lt;/span&gt;是有关Python编程风格的一个推荐标准，详细的内容在网上很容易找到，&amp;nbsp;官方还提供了测试工具，通过以下命令安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo easy_install pep8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装完成后，要测试一个文件是否符合&lt;span class=&#34;caps&#34;&gt;PEP8&lt;/span&gt;，可以用以下命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pep8 --show-source --show-pep8 --statistics --count --benchmark filename.py
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看pep8 -h的介绍，可以很容易清楚上面那些参数是什么意思，
另外还有一个&amp;#8212;ignore的参数，可以指定忽略哪些错误，比如我一般加上&amp;#8212;ignore=E111，&amp;nbsp;忽略要求缩进4个空格，因为我习惯于缩进2个空格&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;super()的用法&lt;/p&gt;
&lt;p&gt;super函数是用来让子类调用父类的同名方法的，在V2.2版本以前，要调用父类的方法，&amp;nbsp;必须要写父类的类名，比如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class A:
  def aaa(self):
    pass
class B(A):
  def aaa(self):
    A.aaa(self)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样有个缺点，万一基类要改名字的话，子类的代码也需要修改，如果有很多个子类，
这将是一个麻烦且容易出错的事情，于是，在V2.2版本，增加了super函数，&amp;nbsp;现在可以这么写&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class A(object):
  def aaa(self):
    pass
class B(A):
  def aaa(self):
    super(B, self).aaa()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意到，A的定义有一点不同，A要继承自object才行，如果不这样继承，
运行到super这里会报错。这是因为，还是在以前，python的类经过一次升级，
如果没有继承自object，认为是old-style，而继承的是new-style，&amp;nbsp;只有new-style才支持这种super的用法。&lt;/p&gt;
&lt;p&gt;另外，在单继承的时候，上面两种方法都可以正常使用，但是在多继承的时候，&amp;nbsp;一般要用super。当然，最好的选择是不使用多继承&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关于字符编码&lt;/p&gt;
&lt;p&gt;在代码中如果出现了中文，那么必须要文件的&lt;strong&gt;第一或第二行&lt;/strong&gt;指明encoding，&amp;nbsp;否则运行会出错，不仅是代码，就算注释有中文，也必须写，格式是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# coding=utf-8
# -*- coding: utf-8 -*-
# vim: set fileencoding=utf-8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这三种语法都行，后两种是顺便可以给其他编辑器看&amp;nbsp;另外，utf-8可能有&lt;span class=&#34;caps&#34;&gt;BOM&lt;/span&gt;的存在，似乎这个问题python编译器会自己解决。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;python文件开头的&lt;code&gt;/usr/bin/env python&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;写过shell脚本的都知道，在开头写上&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以使得脚本可以直接被执行，python文件要直接被执行，也可以用这种办法，&amp;nbsp;只要python文件的第一行写：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/usr/bin/python
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是，有一个小问题，就是每个人安装python的时候，不一定会采用默认的安装位置，&amp;nbsp;也就是说，/usr/bin/python这个文件不一定存在。所以前面那种方法不太可靠。&lt;/p&gt;
&lt;p&gt;而借助env命令，则可以不管代码文件所在位置，只要在&lt;span class=&#34;caps&#34;&gt;PATH&lt;/span&gt;里面，就能被找到。
当然，也存在env命令的位置不正确的可能，但是一般来说，env命令是和系统一起安装的，
很少会改变安装位置（和bash一样），而python一般都是用户自己安装的，
所以安装位置可能会不同。也就是说，env命令改变位置的可能性存在，&amp;nbsp;但是比python命令改变位置的可能性小的多。&lt;/p&gt;
&lt;p&gt;所以，一般python文件的第一行写的就是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还有另外一种方法，使用subshell的方法，也可以自动去&lt;span class=&#34;caps&#34;&gt;PATH&lt;/span&gt;里面搜索python的位置，&amp;nbsp;但是subshell比较浪费资源，不到万不得已，还是少用为好。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除和重新加载指定模块&lt;/p&gt;
&lt;p&gt;验证模块是否已加载&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import sys
if &#39;sys&#39; in sys.modules:
  print &#39;sys in modules&#39;
if &#39;foo&#39; in sys.modules:
  print &#39;foo in modules&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除模块(经测试,&amp;nbsp;这里可以删除sys.modules里面的信息，但是模块还是没有被删除)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import sys
if &#39;ModuleName&#39; in sys.modules:
  del(sys.modules[&#39;ModuleName&#39;])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重新加载模块(可实现守护程序在某个模块更新后，自动加载这个模块)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import foo
foo = reload(foo)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数参数的传递&lt;/p&gt;
&lt;p&gt;最一般的做法，调用是必须给足3个参数，而且顺序不能修改&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def foo(a, b, c)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以提供默认值，这时就可以用foo(b=1, c=2,&amp;nbsp;a=&amp;#8217;a&amp;#8217;)来调用了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def foo(a, b, c=1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果参数个数不定，可以在参数前面加个*，则后面所有的参数，作为一个tuple传入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def foo(a, *b)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;比如上面的函数，如果用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;foo(1, 2) 则a=1, b=(2, )
foo(1) 则 a=1, b=()
foo(1, 2, 3, 4) 则 a=1, b=(2, 3, 4)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还有一种加两个*的，表示可以接受一个字典，比如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def foo(**a)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;则可以这么调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;foo(a=1, b=3, c=5), 则a的值为{a:1, b:3, c:5}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意这里虽然调用的时候，出现给a的赋值，和形参的名字一样，&amp;nbsp;但这只会作为字典的一个元素而已&lt;/p&gt;
&lt;p&gt;结合以上几种方法，定义&lt;/p&gt;
&lt;p&gt;&lt;code&gt;foo(a, b=2, *c, **d)&lt;/code&gt;,&amp;nbsp;则下面的调用所传递的参数如后面所示&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;foo(1)                        a=1, b=2, c=(), d={}
foo(1, 3)                     a=1, b=3, c=(), d={}
foo(1, 2, 3)                  a=1, b=2, c=(3, ) d={}
foo(x=2, b=&#39;0&#39;, d=&#39;&#39;, a=-1)   a=-1, b=&#39;0&#39;, c=(), d={&#39;x&#39;:2, &#39;d&#39;: &#39;&#39;}
foo(1, 2, d=None, 5) 错误，有等号的参数后面不能再有没有等号的参数
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;            </content>
        </entry>
    </feed>